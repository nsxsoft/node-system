import Vue from 'vue';
function debug(type, moduleName, key, args) {
    if (args === void 0) { args = ''; }
    if (Vue.config['debugVuex']) {
        if (args instanceof Array) {
            args = args.join(', ');
        }
        else if (typeof args === 'object') {
            args = Array.prototype.slice.call(args).join(', ');
        }
        console.debug(type + ' - ' + moduleName + '.' + key + '(' + args + ')');
    }
}
export function Getter() {
    // target is the class constructor
    // key is the name of the property
    return function (target, key, descriptor) {
        var hasArguments = !descriptor.get;
        var originalFunction = descriptor.get || descriptor.value;
        // To call the raw getter with the store api
        var getterFunction = function invokeGetter() {
            var res = this.store.getters[this.moduleName + '/' + key];
            // If the getter has arguments, the return will be a function that needs to be executed with the current arguments
            return typeof res === 'function' ? res.apply(this, arguments) : res;
        };
        // This function gets called to compute the value of the getter
        var wrapperFunction = function wrapGetter(state /*, getters, rootState, rootGetters*/) {
            this.state = state;
            var _this = this;
            if (hasArguments) {
                // In case the getter has arguments, we need to wrap inside a function
                return function () {
                    debug('get', this.moduleName, key, arguments);
                    return originalFunction.apply(_this, arguments);
                };
            }
            debug('get', this.moduleName, key);
            return originalFunction.apply(this);
        };
        // Replace the function with the generated function
        hasArguments ? descriptor.value = getterFunction : descriptor.get = getterFunction;
        // Keep a copy of the wrapped function so that it can be registered
        if (!target['_getters']) {
            target['_getters'] = {};
        }
        target['_getters'][key] = wrapperFunction;
    };
}
export function Mutation(params) {
    return function (target, key, descriptor) {
        var originalFunction = descriptor.value;
        var commitFunction = function commitMutation() {
            this.store.commit(this.moduleName + '/' + key, Array.prototype.slice.call(arguments), params ? params.options : undefined);
            return originalFunction._return;
        };
        var wrapperFunction = function wrapMutation(state, args) {
            debug('mut', this.moduleName, key, args);
            this.state = state;
            originalFunction._return = originalFunction.apply(this, args);
        };
        descriptor.value = commitFunction;
        if (!target['_mutations']) {
            target['_mutations'] = {};
        }
        target['_mutations'][key] = wrapperFunction;
    };
}
export function Action() {
    return function (target, key, descriptor) {
        var originalFunction = descriptor.value;
        var dispatchFunction = function dispatchAction() {
            this.store.dispatch(this.moduleName + '/' + key, Array.prototype.slice.call(arguments));
            return originalFunction._return;
        };
        var wrapperFunction = function wrapAction(_a, args) {
            var state = _a.state;
            debug('act', this.moduleName, key, args);
            this.state = state;
            return originalFunction._return = originalFunction.apply(this, args);
        };
        descriptor.value = dispatchFunction;
        if (!target['_actions']) {
            target['_actions'] = {};
        }
        target['_actions'][key] = wrapperFunction;
    };
}
function bindThis(_this, object) {
    var binded = {};
    var _loop_1 = function (key) {
        var fc = object[key];
        binded[key] = function bindThisWrapper() {
            return fc.apply(_this, arguments);
        };
    };
    for (var key in object) {
        _loop_1(key);
    }
    return binded;
}
/**
 * This class is the required base class to be able to use the Getter, Mutation, and Action decorators.
 *
 * The constructor will register itself with the store as a named module.
 *
 * It sets a 'state' and 'store' properties that should be used by child classes.
 */
var ModuleBase = /** @class */ (function () {
    function ModuleBase(moduleName, state, store) {
        this.moduleName = moduleName;
        this.state = state;
        this.store = store;
        var options = {
            namespaced: true,
            state: state,
            getters: bindThis(this, this['_getters']),
            actions: bindThis(this, this['_actions']),
            mutations: bindThis(this, this['_mutations'])
        };
        store.registerModule(this.moduleName, options);
    }
    return ModuleBase;
}());
export { ModuleBase };
