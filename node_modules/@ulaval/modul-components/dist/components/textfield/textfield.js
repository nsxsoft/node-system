var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import Component from 'vue-class-component';
import { Prop, Watch } from 'vue-property-decorator';
import TextareaAutoHeightPlugin from '../../directives/textarea-auto-height/textarea-auto-height';
import { InputLabel } from '../../mixins/input-label/input-label';
import { InputManagement } from '../../mixins/input-management/input-management';
import { InputState } from '../../mixins/input-state/input-state';
import { InputWidth } from '../../mixins/input-width/input-width';
import uuid from '../../utils/uuid/uuid';
import { ModulVue } from '../../utils/vue/vue';
import CharacterCountPlugin from '../character-count/character-count';
import { TEXTFIELD_NAME } from '../component-names';
import IconButtonPlugin from '../icon-button/icon-button';
import InputStyle from '../input-style/input-style';
import ValidationMesagePlugin from '../validation-message/validation-message';
import WithRender from './textfield.html?style=./textfield.scss';
export var MTextfieldType;
(function (MTextfieldType) {
    MTextfieldType["Text"] = "text";
    MTextfieldType["Password"] = "password";
    MTextfieldType["Email"] = "email";
    MTextfieldType["Url"] = "url";
    MTextfieldType["Telephone"] = "tel";
    MTextfieldType["Search"] = "search";
    MTextfieldType["Number"] = "number";
    MTextfieldType["Integer"] = "integer";
})(MTextfieldType || (MTextfieldType = {}));
var ICON_NAME_PASSWORD_VISIBLE = 'm-svg__show';
var ICON_NAME_PASSWORD_HIDDEN = 'm-svg__hide';
var ALLOWED_KEYCODE = [8, 9, 33, 34, 35, 36, 37, 39, 46];
var MTextfield = /** @class */ (function (_super) {
    __extends(MTextfield, _super);
    function MTextfield() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.passwordAsText = false;
        _this.iconDescriptionShowPassword = _this.$i18n.translate('m-textfield:show-password');
        _this.iconDescriptionHidePassword = _this.$i18n.translate('m-textfield:hide-password');
        _this.searchIconDescription = _this.$i18n.translate('m-textfield:search');
        _this.id = "mTextfield-" + uuid.generate();
        return _this;
    }
    MTextfield.prototype.created = function () {
        if (!this.$i18n) {
            throw new Error('<m-text-field> -> this.$i18n is undefined, you must install the i18n plugin.');
        }
    };
    MTextfield.prototype.mounted = function () {
        this.as().trimWordWrap = this.hasWordWrap;
    };
    MTextfield.prototype.typeChanged = function (type) {
        this.$log.warn(TEXTFIELD_NAME + ': Change of property "type" is not supported');
    };
    MTextfield.prototype.inputTypeChanged = function (value) {
        this.as().trimWordWrap = this.hasWordWrap;
    };
    MTextfield.prototype.wordWrapChanged = function (wordWrap) {
        this.as().trimWordWrap = this.hasWordWrap;
    };
    MTextfield.prototype.onPasteTextfield = function (event) {
        if (this.type !== MTextfieldType.Integer) {
            this.$emit('paste', event);
        }
        else {
            var pasteContent = event['clipboardData'].getData('text');
            if (/^\d+$/.test(pasteContent)) {
                if (!isFinite(this.maxLengthNumber) || isFinite(this.maxLengthNumber) && String(pasteContent).length + this.as().internalValue.length <= this.maxLength) {
                    this.$emit('paste', event);
                }
                else {
                    event.preventDefault();
                }
            }
            else {
                event.preventDefault();
            }
        }
    };
    MTextfield.prototype.onKeydownTextfield = function (event) {
        if (this.type !== MTextfieldType.Integer) {
            this.$emit('keydown', event);
        }
        else {
            // tslint:disable-next-line: deprecation
            if (isFinite(this.maxLengthNumber) && this.as().internalValue.length + 1 > this.maxLengthNumber && !event.ctrlKey && ALLOWED_KEYCODE.indexOf(event.keyCode) === -1 || !event.ctrlKey && ALLOWED_KEYCODE.indexOf(event.keyCode) === -1 && this.isNumberKeycode(event.keyCode)) {
                event.preventDefault();
            }
            else {
                this.$emit('keydown', event);
            }
        }
    };
    MTextfield.prototype.isNumberKeycode = function (keycode) {
        return keycode > 31 && (keycode < 48 || keycode > 57) && (keycode < 96 || keycode > 105);
    };
    MTextfield.prototype.onDropTextfield = function (event) {
        if (this.type === MTextfieldType.Integer) {
            event.preventDefault();
        }
    };
    MTextfield.prototype.togglePasswordVisibility = function (event) {
        this.passwordAsText = !this.passwordAsText;
    };
    MTextfield.prototype.onEnter = function () {
        if (this.isTypeSearch) {
            this.search();
        }
    };
    MTextfield.prototype.search = function () {
        this.$emit('search');
    };
    MTextfield.prototype.reset = function () {
        this.$emit('input', '');
    };
    Object.defineProperty(MTextfield.prototype, "inputType", {
        get: function () {
            switch (this.type) {
                case MTextfieldType.Integer:
                    return MTextfieldType.Number;
                case MTextfieldType.Password:
                    return this.passwordAsText ? MTextfieldType.Text : MTextfieldType.Password;
                default:
                    return this.type;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "passwordIcon", {
        get: function () {
            return this.icon && this.type === MTextfieldType.Password && this.as().active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "passwordIconName", {
        get: function () {
            return this.passwordAsText ? ICON_NAME_PASSWORD_HIDDEN : ICON_NAME_PASSWORD_VISIBLE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "passwordIconDescription", {
        get: function () {
            return this.passwordAsText ? this.iconDescriptionHidePassword : this.iconDescriptionShowPassword;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "searchIcon", {
        get: function () {
            return this.icon && this.type === MTextfieldType.Search;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "hasWordWrap", {
        get: function () {
            var hasWordWrap = this.inputType === MTextfieldType.Text && this.wordWrap;
            if (this.inputType !== MTextfieldType.Text && this.wordWrap) {
                this.$log.warn(TEXTFIELD_NAME + ': If you want to use word-wrap prop, you need to set type prop at "text"');
            }
            return hasWordWrap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "valueLength", {
        get: function () {
            return this.internalValue.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "maxLengthNumber", {
        get: function () {
            return !this.lengthOverflow && this.maxLength > 0 ? this.maxLength : Infinity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "hasTextfieldError", {
        get: function () {
            return this.as().hasError;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "isTextfieldValid", {
        get: function () {
            return this.as().isValid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "isTypeSearch", {
        get: function () {
            return this.type === MTextfieldType.Search;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "hasCounterTransition", {
        get: function () {
            return !this.as().hasErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "inputPattern", {
        get: function () {
            return this.type === MTextfieldType.Integer ? '[0-9]*' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTextfield.prototype, "inputMode", {
        get: function () {
            return this.type === MTextfieldType.Integer ? 'numeric' : undefined;
        },
        enumerable: true,
        configurable: true
    });
    MTextfield.prototype.resetModel = function () {
        this.$emit('input', '');
    };
    __decorate([
        Prop({
            default: MTextfieldType.Text,
            validator: function (value) {
                return value === MTextfieldType.Email ||
                    value === MTextfieldType.Password ||
                    value === MTextfieldType.Telephone ||
                    value === MTextfieldType.Text ||
                    value === MTextfieldType.Url ||
                    value === MTextfieldType.Search ||
                    value === MTextfieldType.Number ||
                    value === MTextfieldType.Integer;
            }
        })
    ], MTextfield.prototype, "type", void 0);
    __decorate([
        Prop({ default: true })
    ], MTextfield.prototype, "icon", void 0);
    __decorate([
        Prop({ default: false })
    ], MTextfield.prototype, "wordWrap", void 0);
    __decorate([
        Prop()
    ], MTextfield.prototype, "characterCount", void 0);
    __decorate([
        Prop({ default: 0 })
    ], MTextfield.prototype, "maxLength", void 0);
    __decorate([
        Prop({ default: true })
    ], MTextfield.prototype, "lengthOverflow", void 0);
    __decorate([
        Prop({ default: 0 })
    ], MTextfield.prototype, "characterCountThreshold", void 0);
    __decorate([
        Watch('type')
    ], MTextfield.prototype, "typeChanged", null);
    __decorate([
        Watch('inputType')
    ], MTextfield.prototype, "inputTypeChanged", null);
    __decorate([
        Watch('wordWrap')
    ], MTextfield.prototype, "wordWrapChanged", null);
    MTextfield = __decorate([
        WithRender,
        Component({
            mixins: [
                InputState,
                InputManagement,
                InputWidth,
                InputLabel
            ]
        })
    ], MTextfield);
    return MTextfield;
}(ModulVue));
export { MTextfield };
var TextfieldPlugin = {
    install: function (v, options) {
        v.use(InputStyle);
        v.use(ValidationMesagePlugin);
        v.use(TextareaAutoHeightPlugin);
        v.use(CharacterCountPlugin);
        v.use(IconButtonPlugin);
        v.component(TEXTFIELD_NAME, MTextfield);
    }
};
export default TextfieldPlugin;
//# sourceMappingURL=textfield.js.map