var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import moment from 'moment';
import Component from 'vue-class-component';
import { Prop } from 'vue-property-decorator';
import { InputPopup } from '../../mixins/input-popup/input-popup';
import { InputState } from '../../mixins/input-state/input-state';
import { MediaQueries } from '../../mixins/media-queries/media-queries';
import MediaQueriesPlugin from '../../utils/media-queries/media-queries';
import uuid from '../../utils/uuid/uuid';
import { ModulVue } from '../../utils/vue/vue';
import ButtonPlugin from '../button/button';
import { TIMEPICKER_NAME } from '../component-names';
import InputStylePlugin from '../input-style/input-style';
import PopupPlugin from '../popup/popup';
import ValidationMessagePlugin from '../validation-message/validation-message';
import WithRender from './timepicker.html?style=./timepicker.scss';
var MTimepicker = /** @class */ (function (_super) {
    __extends(MTimepicker, _super);
    function MTimepicker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hours = {};
        _this.selectedHour = NaN;
        _this.selectedMinute = NaN;
        _this.tempHour = NaN;
        _this.tempMinute = NaN;
        _this.placeholder = _this.$i18n.translate('m-timepicker:placeholder');
        _this.okButtonText = _this.$i18n.translate('m-timepicker:button-ok');
        _this.isMousedown = false;
        _this.internalOpen = false;
        _this.internalTimeErrorMessage = '';
        _this.id = "mTimepicker-" + uuid.generate();
        return _this;
    }
    MTimepicker.prototype.mounted = function () {
        moment.locale(this.$i18n.currentLang());
        var newTime = this.duration ? moment.duration(this.min.hours() + ':' + this.min.minutes()) : moment().hours(this.min.hours()).minutes(this.min.minutes());
        while (this.isTimeSameOrBeforeMax(newTime)) {
            var hour = newTime.hours();
            if (!this.hours[hour]) {
                this.hours[hour] = [];
            }
            this.hours[hour].push(newTime.minutes());
            newTime.add(this.step, 'm');
        }
        var roundedTime = this.time.add(Math.round(this.time.minutes() / this.step) * this.step - this.time.minutes(), 'm');
        if (this.isTimeSameOrBeforeMax(roundedTime)) {
            if (this.isTimeSameOrAfterMin(roundedTime)) {
                this.selectedHour = roundedTime.hours();
                this.selectedMinute = roundedTime.minutes();
            }
            else {
                this.selectedHour = this.min.hours();
                this.selectedMinute = this.hours[this.selectedHour][0];
            }
        }
        else {
            this.selectedHour = this.max.hours();
            this.selectedMinute = this.hours[this.selectedHour][this.hours[this.selectedHour].length - 1];
        }
        this.tempHour = this.selectedHour;
        this.tempMinute = this.selectedMinute;
    };
    MTimepicker.prototype.isTimeSameOrBeforeMax = function (time) {
        if (moment.isDuration(time)) {
            return time.asMilliseconds() <= this.max.asMilliseconds();
        }
        else {
            return moment(time).isSameOrBefore(this.max, 'minute');
        }
    };
    MTimepicker.prototype.isTimeSameOrAfterMin = function (time) {
        if (moment.isDuration(time)) {
            return time.asMilliseconds() >= this.min.asMilliseconds();
        }
        else {
            return moment(time).isSameOrAfter(this.min, 'minute');
        }
    };
    Object.defineProperty(MTimepicker.prototype, "minutes", {
        get: function () {
            return this.hours[this.tempHour];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTimepicker.prototype, "formattedTime", {
        get: function () {
            if (this.duration) {
                this.as().internalValue = this.selectedHour + ':' + this.formatMinute(this.selectedMinute);
            }
            else {
                this.as().internalValue = moment().hours(this.selectedHour).minutes(this.selectedMinute).format(this.format);
            }
            return this.as().internalValue;
        },
        set: function (value) {
            this.as().internalValue = value;
        },
        enumerable: true,
        configurable: true
    });
    MTimepicker.prototype.formatHour = function (hour) {
        return !this.duration && hour < 10 ? '0' + hour : hour.toString();
    };
    MTimepicker.prototype.formatMinute = function (minute) {
        return minute < 10 ? '0' + minute : minute.toString();
    };
    MTimepicker.prototype.validateTime = function (event, value) {
        var numbers = value.match(/\d+/g);
        if (numbers && numbers.length === 2) {
            if (isNaN(Number(numbers[0])) || isNaN(Number(numbers[1]))) {
                this.internalTimeErrorMessage = this.$i18n.translate('m-timepicker:error-format');
            }
            else if (Number(numbers[0]) < this.min.hours() || Number(numbers[0]) > this.max.hours()
                || Number(numbers[1]) < this.min.minutes() || Number(numbers[1]) > this.max.minutes()) {
                this.internalTimeErrorMessage = this.$i18n.translate('m-timepicker:out-of-bounds-error');
            }
            else {
                this.selectedHour = parseInt(numbers[0], 10);
                this.selectedMinute = parseInt(numbers[1], 10);
                this.internalTimeErrorMessage = '';
                this.emitChange(this.selectedHour, this.selectedMinute);
            }
        }
        else {
            this.internalTimeErrorMessage = this.$i18n.translate('m-timepicker:error-format');
        }
    };
    Object.defineProperty(MTimepicker.prototype, "timeError", {
        get: function () {
            return this.internalTimeErrorMessage !== '' || this.as().hasError;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTimepicker.prototype, "timeErrorMessage", {
        get: function () {
            return this.as().errorMessage !== undefined ? this.as().errorMessage : this.internalTimeErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MTimepicker.prototype, "open", {
        get: function () {
            return this.internalOpen;
        },
        set: function (open) {
            var _this = this;
            this.internalOpen = open;
            setTimeout(function () {
                if (_this.internalOpen) {
                    var inputEl = _this.$refs.input;
                    inputEl.focus();
                    inputEl.setSelectionRange(0, _this.formattedTime.length);
                    _this.scrollToSelection(_this.$refs.hours);
                    _this.scrollToSelection(_this.$refs.minutes);
                    _this.$emit('open');
                }
                else {
                    _this.$emit('close');
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    MTimepicker.prototype.scrollToSelection = function (container) {
        var selectedElement = container.querySelector('.m--is-selected');
        setTimeout(function () {
            if (selectedElement) {
                container.scrollTop = selectedElement['offsetTop'] - container.clientHeight / 2 + selectedElement.clientHeight / 2;
            }
        }, 10);
    };
    MTimepicker.prototype.onScroll = function (event) {
        var _this = this;
        if (!this.isMousedown) {
            clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(function () {
                // tslint:disable-next-line: deprecation
                if (event.srcElement) {
                    // tslint:disable-next-line: deprecation
                    _this.positionScroll(event.srcElement);
                }
            }, 300);
        }
    };
    MTimepicker.prototype.onMousedown = function (event) {
        this.isMousedown = true;
    };
    MTimepicker.prototype.onMouseup = function (event) {
        this.isMousedown = false;
        // tslint:disable-next-line: deprecation
        if (event.srcElement) {
            // tslint:disable-next-line: deprecation
            this.positionScroll(event.srcElement);
        }
    };
    MTimepicker.prototype.positionScroll = function (el) {
        el.scrollTop = Math.round(el.scrollTop / 44) * 44;
    };
    MTimepicker.prototype.selectHour = function (hour) {
        this.tempHour = hour;
    };
    MTimepicker.prototype.selectMinute = function (minute) {
        this.tempMinute = minute;
    };
    MTimepicker.prototype.onOk = function () {
        this.selectedHour = this.tempHour;
        this.selectedMinute = this.tempMinute;
        this.emitChange(this.selectedHour, this.selectedMinute);
        this.open = false;
    };
    MTimepicker.prototype.emitChange = function (hour, minute) {
        if (this.duration) {
            this.$emit('change', moment.duration(hour + ':' + minute));
        }
        else {
            this.$emit('change', moment().hours(hour).minutes(minute));
        }
    };
    Object.defineProperty(MTimepicker.prototype, "ariaControls", {
        get: function () {
            return this.id + '-controls';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Prop()
    ], MTimepicker.prototype, "label", void 0);
    __decorate([
        Prop()
    ], MTimepicker.prototype, "duration", void 0);
    __decorate([
        Prop({ default: function () { return this.duration ? moment.duration('1:0') : moment(); } })
    ], MTimepicker.prototype, "time", void 0);
    __decorate([
        Prop({ default: function () { return this.duration ? moment.duration('0:0') : moment().hours(0).minutes(0); } })
    ], MTimepicker.prototype, "min", void 0);
    __decorate([
        Prop({ default: function () { return this.duration ? moment.duration('4:0') : moment().hours(23).minutes(59); } })
    ], MTimepicker.prototype, "max", void 0);
    __decorate([
        Prop({ default: 5 })
    ], MTimepicker.prototype, "step", void 0);
    __decorate([
        Prop({ default: 'LT' })
    ], MTimepicker.prototype, "format", void 0);
    MTimepicker = __decorate([
        WithRender,
        Component({
            mixins: [
                InputState,
                InputPopup,
                MediaQueries
            ]
        })
    ], MTimepicker);
    return MTimepicker;
}(ModulVue));
export { MTimepicker };
var TimepickerPlugin = {
    install: function (v, options) {
        v.prototype.$log.error('MTimepicker will be deprecated in modul v.1.0');
        v.use(InputStylePlugin);
        v.use(ButtonPlugin);
        v.use(PopupPlugin);
        v.use(ValidationMessagePlugin);
        v.use(MediaQueriesPlugin);
        v.component(TIMEPICKER_NAME, MTimepicker);
    }
};
export default TimepickerPlugin;
//# sourceMappingURL=timepicker.js.map