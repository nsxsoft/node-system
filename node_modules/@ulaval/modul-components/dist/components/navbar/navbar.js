var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import Component from 'vue-class-component';
import { Prop, Watch } from 'vue-property-decorator';
import { ElementQueries } from '../../mixins/element-queries/element-queries';
import ModulPlugin from '../../utils/modul/modul';
import { ModulVue } from '../../utils/vue/vue';
import { NAVBAR_ITEM_NAME, NAVBAR_NAME } from '../component-names';
import IconButtonPlugin from '../icon-button/icon-button';
import { MNavbarItem } from './navbar-item/navbar-item';
import WithRender from './navbar.html?style=./navbar.scss';
var OVERFLOWOFFSET = 20;
var BaseNavbar = /** @class */ (function (_super) {
    __extends(BaseNavbar, _super);
    function BaseNavbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BaseNavbar;
}(ModulVue));
export { BaseNavbar };
export var MNavbarSkin;
(function (MNavbarSkin) {
    MNavbarSkin["NavMain"] = "nav-main";
    MNavbarSkin["NavSub"] = "nav-sub";
    MNavbarSkin["NavSoft"] = "nav-soft";
    MNavbarSkin["TabLight"] = "tab-light";
    MNavbarSkin["TabDark"] = "tab-dark";
    MNavbarSkin["TabArrow"] = "tab-arrow";
    MNavbarSkin["TabUnderline"] = "tab-underline";
    MNavbarSkin["TabSoft"] = "tab-soft";
    MNavbarSkin["Plain"] = "plain";
})(MNavbarSkin || (MNavbarSkin = {}));
export var MNavbarMaxWidth;
(function (MNavbarMaxWidth) {
    MNavbarMaxWidth["XLarge"] = "1400px";
    MNavbarMaxWidth["Large"] = "1200px";
    MNavbarMaxWidth["Regular"] = "1000px";
    MNavbarMaxWidth["Small"] = "800px";
    MNavbarMaxWidth["Text"] = "720px";
})(MNavbarMaxWidth || (MNavbarMaxWidth = {}));
var MNavbar = /** @class */ (function (_super) {
    __extends(MNavbar, _super);
    function MNavbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.animReady = false;
        _this.internalValue = '';
        _this.showArrowLeft = false;
        _this.showArrowRight = false;
        _this.computedHeight = 0;
        return _this;
    }
    MNavbar.prototype.updateValue = function (value) {
        this.model = value;
    };
    MNavbar.prototype.onMouseover = function (event, value) {
        this.$emit('mouseover', event, value);
    };
    MNavbar.prototype.onMouseleave = function (event, value) {
        this.$emit('mouseleave', event, value);
    };
    MNavbar.prototype.onClick = function (event, value) {
        this.$emit('click', event, value);
    };
    Object.defineProperty(MNavbar.prototype, "model", {
        get: function () {
            return this.selected === undefined ? this.internalValue : this.selected;
        },
        set: function (value) {
            this.setAndUpdate(value);
            this.$emit('update:selected', value);
        },
        enumerable: true,
        configurable: true
    });
    MNavbar.prototype.created = function () {
        this.internalValue = undefined;
    };
    MNavbar.prototype.mounted = function () {
        var _this = this;
        this.setupScrolllH();
        this.as().$on('resize', this.setupScrolllH);
        this.$children.forEach(function (child) {
            child.$on('resize', _this.setupScrolllH);
        });
        this.$refs.wrap.addEventListener('scroll', this.setDisplayButtonArrrow);
    };
    MNavbar.prototype.beforeDestroy = function () {
        this.as().$off('resize', this.setupScrolllH);
        this.$refs.wrap.removeEventListener('scroll', this.setDisplayButtonArrrow);
    };
    MNavbar.prototype.multilineChanged = function () {
        var _this = this;
        // Wait for navbar-item height calculation -> setimension()
        setTimeout(function () {
            _this.setupScrolllH();
        });
    };
    MNavbar.prototype.setDisplayButtonArrrow = function () {
        var wrapEl = this.$refs.wrap;
        if (wrapEl) {
            var maxScrollLeft = wrapEl.scrollWidth - wrapEl.clientWidth;
            this.showArrowRight = wrapEl.scrollLeft < maxScrollLeft;
            this.showArrowLeft = wrapEl.scrollLeft > 0;
        }
    };
    Object.defineProperty(MNavbar.prototype, "hasArrowRight", {
        get: function () {
            return this.showArrowRight && this.navigationArrow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MNavbar.prototype, "hasArrowLeft", {
        get: function () {
            return this.showArrowLeft && this.navigationArrow;
        },
        enumerable: true,
        configurable: true
    });
    MNavbar.prototype.setSelectedIndicatorPosition = function (element, ref) {
        var positionX = element.$el.offsetLeft;
        var width = element.$el.clientWidth;
        var localRef = this.$refs[ref];
        localRef.style.transform = 'translate3d(' + positionX + 'px, 0, 0)';
        localRef.style.width = width + 'px';
    };
    MNavbar.prototype.setAndUpdate = function (value) {
        this.internalValue = value;
        this.scrollToSelected();
    };
    MNavbar.prototype.setupScrolllH = function () {
        var _this = this;
        var contentsEl = this.$refs.contents;
        var wrapEl = this.$refs.wrap;
        var listEl = this.$refs.list;
        if (wrapEl.scrollWidth > wrapEl.clientWidth) {
            this.computedHeight = listEl.clientHeight;
            wrapEl.style.height = this.computedHeight + OVERFLOWOFFSET + 'px';
            contentsEl.style.height = this.computedHeight + 'px';
            this.scrollToSelected();
            this.setDisplayButtonArrrow();
        }
        else {
            this.showArrowLeft = false;
            this.showArrowRight = false;
            wrapEl.style.removeProperty('height');
            contentsEl.style.removeProperty('height');
        }
        if (!this.animReady) {
            setTimeout(function () {
                _this.animReady = true;
            });
        }
    };
    MNavbar.prototype.scrollToSelected = function () {
        var _this = this;
        this.navbarItems().elements.forEach(function (element) {
            // Allow time to make sure an item is selected
            setTimeout(function () {
                var wrapEl = _this.$refs.wrap;
                if (element && element.$props.value === _this.model && wrapEl) {
                    var buttonLeftWidth = _this.$refs.buttonLeft && _this.hasArrowLeft ? _this.$refs.buttonLeft.clientWidth : 0;
                    var buttonRightWidth = _this.$refs.buttonRight && _this.hasArrowRight ? _this.$refs.buttonRight.clientWidth : 0;
                    var scrollPositionAlignLeft = element.$el.offsetLeft - buttonLeftWidth;
                    // Check if selected element is visible in navbar
                    if (wrapEl && wrapEl.clientWidth > (element.$el.offsetLeft - wrapEl.scrollLeft + buttonRightWidth)) {
                        // Check if the selected element exceeds on the left side
                        if ((element.$el.offsetLeft - buttonLeftWidth - wrapEl.scrollLeft) < 0) {
                            wrapEl.scrollLeft = scrollPositionAlignLeft;
                            // Check if the selected element exceeds on the right side
                        }
                        else if (wrapEl.clientWidth < (element.$el.offsetLeft - wrapEl.scrollLeft + element.$el.clientWidth - buttonRightWidth)) {
                            wrapEl.scrollLeft = wrapEl.scrollLeft + element.$el.clientWidth + buttonRightWidth - (wrapEl.scrollLeft + wrapEl.clientWidth - element.$el.offsetLeft);
                        }
                    }
                    else if (wrapEl) {
                        wrapEl.scrollLeft = scrollPositionAlignLeft;
                    }
                    if (_this.skin === MNavbarSkin.TabUnderline || _this.skin === MNavbarSkin.TabArrow) {
                        _this.setSelectedIndicatorPosition(element, _this.skin);
                    }
                    _this.setDisplayButtonArrrow();
                }
            });
        });
    };
    Object.defineProperty(MNavbar.prototype, "buttonSkin", {
        get: function () {
            return this.skin === MNavbarSkin.NavMain || this.skin === MNavbarSkin.NavSub || this.skin === MNavbarSkin.NavSoft || this.skin === MNavbarSkin.TabDark ? 'dark' : 'light';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MNavbar.prototype, "buttonRipple", {
        get: function () {
            return this.skin === MNavbarSkin.TabUnderline || this.skin === MNavbarSkin.TabArrow || this.skin === MNavbarSkin.TabSoft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MNavbar.prototype, "isTabUnderlineSkin", {
        get: function () {
            return this.skin === MNavbarSkin.TabUnderline;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MNavbar.prototype, "isTabArrowSkin", {
        get: function () {
            return this.skin === MNavbarSkin.TabArrow;
        },
        enumerable: true,
        configurable: true
    });
    MNavbar.prototype.navbarItems = function () {
        var navbarItems = this.$children.filter(function (element) {
            return element instanceof MNavbarItem;
        });
        // find first item
        var firstElement = navbarItems[0].$el;
        // find last item
        var lastElement = navbarItems[navbarItems.length - 1].$el;
        return {
            elements: navbarItems,
            firstElement: firstElement,
            lastElement: lastElement
        };
    };
    MNavbar.prototype.scrollLeft = function () {
        var wrapEl = this.$refs.wrap;
        var outbound;
        // find the previus element outside visible area
        this.navbarItems().elements.forEach(function (element) {
            if (element.$el.offsetLeft < wrapEl.scrollLeft) {
                outbound = element;
            }
        });
        if (outbound) {
            wrapEl.scrollLeft = outbound.$el.offsetLeft - this.$refs.buttonLeft.clientWidth;
        }
    };
    MNavbar.prototype.scrollRight = function () {
        var wrapEl = this.$refs.wrap;
        // let maxScrollLeft: number = wrapEl.scrollWidth - wrapEl.clientWidth;
        var cRight = wrapEl.scrollLeft + wrapEl.clientWidth;
        // find the next element outside visible area
        var outbound = this.navbarItems().elements.find(function (element) { return element.$el.offsetLeft + element.$el.clientWidth > cRight; });
        if (outbound) {
            // get the threshold of visible part of the element
            var threshold = cRight - outbound.$el.offsetLeft;
            // move the container scroll
            wrapEl.scrollLeft += (outbound.$el.clientWidth + this.$refs.buttonRight.clientWidth) - threshold;
        }
    };
    __decorate([
        Prop()
    ], MNavbar.prototype, "selected", void 0);
    __decorate([
        Prop({
            default: MNavbarSkin.NavMain,
            validator: function (value) {
                return value === MNavbarSkin.NavMain ||
                    value === MNavbarSkin.NavSub ||
                    value === MNavbarSkin.NavSoft ||
                    value === MNavbarSkin.TabLight ||
                    value === MNavbarSkin.TabDark ||
                    value === MNavbarSkin.TabArrow ||
                    value === MNavbarSkin.TabUnderline ||
                    value === MNavbarSkin.TabSoft ||
                    value === MNavbarSkin.Plain;
            }
        })
    ], MNavbar.prototype, "skin", void 0);
    __decorate([
        Prop()
    ], MNavbar.prototype, "disabled", void 0);
    __decorate([
        Prop({ default: true })
    ], MNavbar.prototype, "navigationArrow", void 0);
    __decorate([
        Prop({ default: MNavbarMaxWidth.Large })
    ], MNavbar.prototype, "maxWidth", void 0);
    __decorate([
        Prop({ default: true })
    ], MNavbar.prototype, "multiline", void 0);
    __decorate([
        Prop()
    ], MNavbar.prototype, "titleButtonLeft", void 0);
    __decorate([
        Prop()
    ], MNavbar.prototype, "titleButtonRight", void 0);
    __decorate([
        Prop({ default: false })
    ], MNavbar.prototype, "autoSelect", void 0);
    __decorate([
        Watch('multiline')
    ], MNavbar.prototype, "multilineChanged", null);
    __decorate([
        Watch('selected')
    ], MNavbar.prototype, "setAndUpdate", null);
    MNavbar = __decorate([
        WithRender,
        Component({
            mixins: [ElementQueries]
        })
    ], MNavbar);
    return MNavbar;
}(BaseNavbar));
export { MNavbar };
var NavbarPlugin = {
    install: function (v, options) {
        v.use(ModulPlugin);
        v.use(IconButtonPlugin);
        v.component(NAVBAR_ITEM_NAME, MNavbarItem);
        v.component(NAVBAR_NAME, MNavbar);
    }
};
export default NavbarPlugin;
//# sourceMappingURL=navbar.js.map