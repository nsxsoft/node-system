import uuid from '../uuid/uuid';
import { FormState } from './form-state/form-state';
/**
 * Form Class
 */
var Form = /** @class */ (function () {
    /**
     *
     * @param fieldGroup the group of field that populate the form
     * @param validationCallbacks a list of function to call to verify the form's state
     */
    function Form(fieldGroup, validationCallbacks) {
        if (validationCallbacks === void 0) { validationCallbacks = []; }
        this.fieldGroup = fieldGroup;
        this.validationCallbacks = validationCallbacks;
        this.id = uuid.generate();
        this.internalState = new FormState();
    }
    Object.defineProperty(Form.prototype, "fields", {
        /**
         * return the form fields
         */
        get: function () {
            var _this = this;
            return Object.keys(this.fieldGroup)
                .map(function (name) { return _this.fieldGroup[name]; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "totalNbOfErrors", {
        /**
         * Total number of errors
         */
        get: function () {
            return this.nbFieldsThatHasError + this.nbOfErrors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "nbFieldsThatHasError", {
        /**
         * Number of fields that have errors
         */
        get: function () {
            return this.fields.filter(function (field) { return field.hasError; }).length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "nbOfErrors", {
        /**
         * Number of form errors
         */
        get: function () {
            return this.internalState.errorMessages.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "isValid", {
        /**
         * return true if the form contains no field with errors
         */
        get: function () {
            return this.nbFieldsThatHasError === 0 && this.nbOfErrors === 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the formField with the coresponding name
     *
     * @param formFieldName the name of the formfield to access
     */
    Form.prototype.get = function (formFieldName) {
        var formField = this.fieldGroup[formFieldName];
        if (!formField) {
            throw new Error('Trying to access an non existing form field');
        }
        return this.fieldGroup[formFieldName];
    };
    /**
     * reset all fields in the form without validating
     */
    Form.prototype.reset = function () {
        this.fields.forEach(function (field) {
            field.reset();
        });
        this.internalState = new FormState();
    };
    /**
     * returns all the messages that must be shown in the summary
     */
    Form.prototype.getErrorsForSummary = function () {
        var errorsSummary = [];
        this.internalState.errorMessages.forEach(function (message) {
            errorsSummary.push(message);
        });
        this.fields.forEach(function (field) {
            errorsSummary.push(field.errorMessageSummary[0]);
        });
        return errorsSummary;
    };
    Form.prototype.focusFirstFieldWithError = function () {
        var fieldWithError = this.fields.find(function (field) {
            return field.hasError;
        });
        if (fieldWithError) {
            fieldWithError.shouldFocus = true;
        }
    };
    /**
     * validate all fields in the form
     */
    Form.prototype.validateAll = function () {
        var _this = this;
        this.fields.forEach(function (field) {
            field.touch();
        });
        this.internalState = new FormState();
        this.validationCallbacks.forEach(function (validationCallback) {
            _this.changeState(validationCallback(_this));
        });
    };
    Form.prototype.changeState = function (formValidation) {
        if (!formValidation.hasError) {
            return;
        }
        this.internalState.hasErrors = true;
        this.internalState.errorMessages = this.internalState.errorMessages.concat(formValidation.errorMessage);
    };
    return Form;
}());
export { Form };
//# sourceMappingURL=form.js.map