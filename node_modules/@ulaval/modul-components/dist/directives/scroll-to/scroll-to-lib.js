export var ScrollToDuration;
(function (ScrollToDuration) {
    ScrollToDuration["Null"] = "null";
    ScrollToDuration["Slow"] = "slow";
    ScrollToDuration["Slower"] = "slower";
    ScrollToDuration["Regular"] = "regular";
    ScrollToDuration["Fast"] = "fast";
})(ScrollToDuration || (ScrollToDuration = {}));
/**
 * @deprecated use global service in /utils/scroll-to.
 */
var ScrollTo = /** @class */ (function () {
    function ScrollTo() {
    }
    // https://coderwall.com/p/hujlhg/smooth-scrolling-without-jquery
    ScrollTo.prototype.scrollToTop = function (element, duration) {
        if (duration === void 0) { duration = ScrollToDuration.Regular; }
        return this.intertnalStartScroll(element, 0, duration);
    };
    ScrollTo.prototype.scrollToBottom = function (element, duration) {
        if (duration === void 0) { duration = ScrollToDuration.Regular; }
        return this.intertnalStartScroll(element, element.offsetHeight, duration);
    };
    ScrollTo.prototype.startScroll = function (element, target, duration) {
        if (element === void 0) { element = document.body; }
        if (target === void 0) { target = 0; }
        if (duration === void 0) { duration = ScrollToDuration.Regular; }
        return this.intertnalStartScroll(element, target, duration).promise;
    };
    ScrollTo.prototype.intertnalStartScroll = function (element, target, duration) {
        if (element === void 0) { element = document.body; }
        if (target === void 0) { target = 0; }
        if (duration === void 0) { duration = ScrollToDuration.Regular; }
        target = Math.round(target);
        var time;
        var cancelled = false;
        var cancel = function () {
            cancelled = true;
            if (currentFrame) {
                cancelAnimationFrame(currentFrame);
                currentFrame = undefined;
            }
        };
        var currentFrame;
        switch (duration) {
            case ScrollToDuration.Null:
                time = 0;
                break;
            case ScrollToDuration.Slow:
                time = 1500;
                break;
            case ScrollToDuration.Slower:
                time = 3000;
                break;
            case ScrollToDuration.Fast:
                time = 400;
                break;
            default:
                time = 800;
        }
        if (time < 0) {
            return { promise: Promise.reject('bad duration'), cancel: function () { return cancel(); } };
        }
        if (time === 0) {
            element.scrollTop = target;
            return { promise: Promise.resolve(), cancel: function () { return cancel(); } };
        }
        var startTime = Date.now();
        var endTime = startTime + time;
        var startTop = window.pageYOffset;
        var distance = target - startTop;
        // based on http://en.wikipedia.org/wiki/Smoothstep
        var smoothStep = function (start, end, point) {
            if (point <= start) {
                return 0;
            }
            if (point >= end) {
                return 1;
            }
            var x = (point - start) / (end - start); // interpolation
            return x * x * (3 - 2 * x);
        };
        return {
            promise: new Promise(function (resolve, reject) {
                // This is to keep track of where the element's scrollTop is
                // supposed to be, based on what we're doing
                var previousTop = window.pageYOffset;
                // This is like a think function from a game loop
                var scrollFrame = function () {
                    if (window.pageYOffset !== previousTop || cancelled) {
                        resolve();
                        return;
                    }
                    // set the scrollTop for this frame
                    var now = Date.now();
                    var point = smoothStep(startTime, endTime, now);
                    var frameTop = Math.round(startTop + distance * point);
                    window.scrollTo(0, frameTop);
                    // check if we're done!
                    if (now >= endTime) {
                        resolve();
                        return;
                    }
                    // If we were supposed to scroll but didn't, then we
                    // probably hit the limit, so consider it done; not
                    // interrupted.
                    if (window.pageYOffset === previousTop &&
                        window.pageYOffset !== frameTop) {
                        resolve();
                        return;
                    }
                    previousTop = window.pageYOffset;
                    // schedule next frame for execution
                    currentFrame = requestAnimationFrame(scrollFrame);
                };
                // boostrap the animation process
                currentFrame = requestAnimationFrame(scrollFrame);
            }), cancel: function () { return cancel(); }
        };
    };
    return ScrollTo;
}());
export { ScrollTo };
// tslint:disable-next-line: deprecation
var ScrollToLib = new ScrollTo();
export default ScrollToLib;
//# sourceMappingURL=scroll-to-lib.js.map